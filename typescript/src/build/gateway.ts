import * as fs from 'fs';
import * as path from 'path';
import YAML from 'yaml';
import { Handler } from '../annotations';
import { Logger } from './types';

/**
 * Generator for API Gateway configuration
 */
export class GatewayGenerator {
  constructor(
    private handlers: Handler[],
    private outputDir: string,
    private moduleName: string,
    private projectId: string,
    private region: string,
    private logger: Logger
  ) {}

  /**
   * Generate API Gateway configuration
   */
  async generate(): Promise<void> {
    this.logger.info('Generating API Gateway configuration', {
      handlers: this.handlers.length,
      outputDir: this.outputDir
    });

    // Create output directory
    await fs.promises.mkdir(this.outputDir, { recursive: true });

    // Generate OpenAPI spec
    await this.generateOpenAPISpec();

    // Generate gateway config
    await this.generateGatewayConfig();

    this.logger.info('Generated API Gateway configuration', {
      openapi: path.join(this.outputDir, 'openapi.yaml')
    });
  }

  /**
   * Generate OpenAPI 3.0 specification
   */
  private async generateOpenAPISpec(): Promise<void> {
    const spec = {
      openapi: '3.0.0',
      info: {
        title: `${this.moduleName} API`,
        description: 'API generated by Box framework',
        version: '1.0.0'
      },
      servers: [
        {
          url: `https://${this.projectId}.appspot.com`,
          description: 'Production server'
        },
        {
          url: `https://${this.region}-${this.projectId}.cloudfunctions.net`,
          description: 'Cloud Functions'
        }
      ],
      paths: this.generatePaths(),
      components: {
        securitySchemes: {
          bearerAuth: {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT'
          }
        },
        responses: {
          UnauthorizedError: {
            description: 'Access token is missing or invalid'
          },
          NotFoundError: {
            description: 'Resource not found'
          },
          InternalError: {
            description: 'Internal server error'
          }
        }
      }
    };

    const yamlContent = YAML.stringify(spec);
    await fs.promises.writeFile(
      path.join(this.outputDir, 'openapi.yaml'),
      yamlContent
    );
  }

  /**
   * Generate paths for OpenAPI spec
   */
  private generatePaths(): any {
    const paths: any = {};

    for (const handler of this.handlers) {
      const path = handler.route.path;
      const method = handler.route.method.toLowerCase();

      if (!paths[path]) {
        paths[path] = {};
      }

      paths[path][method] = this.generateOperation(handler);
    }

    return paths;
  }

  /**
   * Generate operation for a handler
   */
  private generateOperation(handler: Handler): any {
    const operation: any = {
      summary: handler.functionName,
      description: `${handler.route.method} ${handler.route.path}`,
      operationId: handler.functionName,
      tags: [handler.packageName],
      responses: {
        '200': {
          description: 'Successful response',
          content: {
            'application/json': {
              schema: {
                type: 'object'
              }
            }
          }
        },
        '401': {
          $ref: '#/components/responses/UnauthorizedError'
        },
        '404': {
          $ref: '#/components/responses/NotFoundError'
        },
        '500': {
          $ref: '#/components/responses/InternalError'
        }
      }
    };

    // Add security if required
    if (handler.auth === 'required') {
      operation.security = [{ bearerAuth: [] }];
    }

    // Add request body for POST/PUT/PATCH
    if (['POST', 'PUT', 'PATCH'].includes(handler.route.method)) {
      operation.requestBody = {
        required: true,
        content: {
          'application/json': {
            schema: {
              type: 'object'
            }
          }
        }
      };
    }

    // Add path parameters
    const pathParams = handler.route.path.match(/:(\w+)/g);
    if (pathParams) {
      operation.parameters = pathParams.map((param: string) => ({
        name: param.substring(1),
        in: 'path',
        required: true,
        schema: {
          type: 'string'
        }
      }));
    }

    // Add rate limit info
    if (handler.rateLimit) {
      operation['x-google-ratelimit'] = {
        requests: handler.rateLimit.requests,
        period: handler.rateLimit.period
      };
    }

    return operation;
  }

  /**
   * Generate gateway-config.yaml
   */
  private async generateGatewayConfig(): Promise<void> {
    const config = {
      swagger: '2.0',
      info: {
        title: `${this.moduleName} API Gateway`,
        description: 'API Gateway configuration',
        version: '1.0.0'
      },
      schemes: ['https'],
      produces: ['application/json'],
      'x-google-backend': {
        address: `https://${this.region}-${this.projectId}.cloudfunctions.net`,
        deadline: 30.0
      }
    };

    const yamlContent = YAML.stringify(config);
    await fs.promises.writeFile(
      path.join(this.outputDir, 'gateway-config.yaml'),
      yamlContent
    );
  }
}
