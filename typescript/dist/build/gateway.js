"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GatewayGenerator = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const yaml_1 = __importDefault(require("yaml"));
/**
 * Generator for API Gateway configuration
 */
class GatewayGenerator {
    handlers;
    outputDir;
    moduleName;
    projectId;
    region;
    logger;
    constructor(handlers, outputDir, moduleName, projectId, region, logger) {
        this.handlers = handlers;
        this.outputDir = outputDir;
        this.moduleName = moduleName;
        this.projectId = projectId;
        this.region = region;
        this.logger = logger;
    }
    /**
     * Generate API Gateway configuration
     */
    async generate() {
        this.logger.info('Generating API Gateway configuration', {
            handlers: this.handlers.length,
            outputDir: this.outputDir
        });
        // Create output directory
        await fs.promises.mkdir(this.outputDir, { recursive: true });
        // Generate OpenAPI spec
        await this.generateOpenAPISpec();
        // Generate gateway config
        await this.generateGatewayConfig();
        this.logger.info('Generated API Gateway configuration', {
            openapi: path.join(this.outputDir, 'openapi.yaml')
        });
    }
    /**
     * Generate OpenAPI 3.0 specification
     */
    async generateOpenAPISpec() {
        const spec = {
            openapi: '3.0.0',
            info: {
                title: `${this.moduleName} API`,
                description: 'API generated by Box framework',
                version: '1.0.0'
            },
            servers: [
                {
                    url: `https://${this.projectId}.appspot.com`,
                    description: 'Production server'
                },
                {
                    url: `https://${this.region}-${this.projectId}.cloudfunctions.net`,
                    description: 'Cloud Functions'
                }
            ],
            paths: this.generatePaths(),
            components: {
                securitySchemes: {
                    bearerAuth: {
                        type: 'http',
                        scheme: 'bearer',
                        bearerFormat: 'JWT'
                    }
                },
                responses: {
                    UnauthorizedError: {
                        description: 'Access token is missing or invalid'
                    },
                    NotFoundError: {
                        description: 'Resource not found'
                    },
                    InternalError: {
                        description: 'Internal server error'
                    }
                }
            }
        };
        const yamlContent = yaml_1.default.stringify(spec);
        await fs.promises.writeFile(path.join(this.outputDir, 'openapi.yaml'), yamlContent);
    }
    /**
     * Generate paths for OpenAPI spec
     */
    generatePaths() {
        const paths = {};
        for (const handler of this.handlers) {
            const path = handler.route.path;
            const method = handler.route.method.toLowerCase();
            if (!paths[path]) {
                paths[path] = {};
            }
            paths[path][method] = this.generateOperation(handler);
        }
        return paths;
    }
    /**
     * Generate operation for a handler
     */
    generateOperation(handler) {
        const operation = {
            summary: handler.functionName,
            description: `${handler.route.method} ${handler.route.path}`,
            operationId: handler.functionName,
            tags: [handler.packageName],
            responses: {
                '200': {
                    description: 'Successful response',
                    content: {
                        'application/json': {
                            schema: {
                                type: 'object'
                            }
                        }
                    }
                },
                '401': {
                    $ref: '#/components/responses/UnauthorizedError'
                },
                '404': {
                    $ref: '#/components/responses/NotFoundError'
                },
                '500': {
                    $ref: '#/components/responses/InternalError'
                }
            }
        };
        // Add security if required
        if (handler.auth === 'required') {
            operation.security = [{ bearerAuth: [] }];
        }
        // Add request body for POST/PUT/PATCH
        if (['POST', 'PUT', 'PATCH'].includes(handler.route.method)) {
            operation.requestBody = {
                required: true,
                content: {
                    'application/json': {
                        schema: {
                            type: 'object'
                        }
                    }
                }
            };
        }
        // Add path parameters
        const pathParams = handler.route.path.match(/:(\w+)/g);
        if (pathParams) {
            operation.parameters = pathParams.map((param) => ({
                name: param.substring(1),
                in: 'path',
                required: true,
                schema: {
                    type: 'string'
                }
            }));
        }
        // Add rate limit info
        if (handler.rateLimit) {
            operation['x-google-ratelimit'] = {
                requests: handler.rateLimit.requests,
                period: handler.rateLimit.period
            };
        }
        return operation;
    }
    /**
     * Generate gateway-config.yaml
     */
    async generateGatewayConfig() {
        const config = {
            swagger: '2.0',
            info: {
                title: `${this.moduleName} API Gateway`,
                description: 'API Gateway configuration',
                version: '1.0.0'
            },
            schemes: ['https'],
            produces: ['application/json'],
            'x-google-backend': {
                address: `https://${this.region}-${this.projectId}.cloudfunctions.net`,
                deadline: 30.0
            }
        };
        const yamlContent = yaml_1.default.stringify(config);
        await fs.promises.writeFile(path.join(this.outputDir, 'gateway-config.yaml'), yamlContent);
    }
}
exports.GatewayGenerator = GatewayGenerator;
//# sourceMappingURL=gateway.js.map